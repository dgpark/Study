Delaunay Trianglue

#Python의 numpy, scipy를 import하면 G=Del(T)와 같은 형식으로 Delaunay Trianguler을 사용가능.
(정확한 표현은 아님. 쓰려면 개념과 사용법 찾아보기.)


분류 방법 : key 전체사용, key 부분사용

-> Radix Sort(key 부분사용) :
ex) 325, 217, 067, 452 ... 등의 숫자가 존재할때,
통을 10개 만든다. (0~9) 그리고, 앞 첫째자리에 따라 앞의 통에 분류를 한다.
그리고 나서, 각 통마다 Sorting을 한다.


- Tag Sorting


Good Sorting : 
1) 시간이 짧게 끝나야 한다. (시간의 문제)
 - 기본 연산의 횟수를 작게 한다.
 - data move 횟수를 작게 한다.

2) in-place 알고리즘 (공간의 문제) -> 추가 메모리를 요구하지 않는 Sorting. (But, 복잡해짐)


< 정렬 >

Insertion : 삽입 정렬 -> index를 더해가면서 새 index의 위치에 값을 이동시키는것
(ex : 7,1,4,2,5,3,6,8 -> 1,7,4,2,5,3,6,8 -> 1,4,7,2,5,3,6,8 -> 1,2,4,7,5,3,6,8 .....)

Bublle (or) exchange : 버블 정렬
(ex : 7,1,4,2,5,3,6,8 -> 1,7,4,2,5,3,6,8 -> 1,4,7,2,5,3,6,8 -> 1,4,2,7,5,3,6,8 .....)

Selection : 선택 정렬 -> N번 index 탐색하면서 min값을 저장.(해당값을 맨앞으로, 그다음 min값 찾아서 그다음으로 옮기는 식으로 진행)
(ex : 7,1,4,2,5,3,6,8 -> 1,7,4,2,5,3,6,8 -> 1,2,7,4,5,3,6,8 - > 1,2,3,7,4,5,6,8 .....)


< 비교 >
best :
- 삽입정렬 : N
- 버블정렬 : (N/2)*(N-1)
- 삽입정렬 : (N/2)*(N-1)

worst :
- 삽입정렬 : (N/2)*(N-1)
- 버블정렬 : (N/2)*(N-1)
- 선택정렬 : (N/2)*(N-1)


< 이동 >
best :
- 삽입정렬 : 0
- 버블정렬 : 0
- 삽입정렬 : 0

worst :
- 삽입정렬 : (N/2)*(N-1)
- 버블정렬 : (N/2)*(N-1)
- 선택정렬 : N (?????)

< 추가 메모리 >
- 삽입정렬 : X
- 버블정렬 : X
- 선택정렬 : X


< Inversion >
: 작은값이 큰 값보다 뒤에 있는 경우
- Inversion이 가장 많이 되어 있는 case : 9 8 7 6 5 4 2

bubble Sort
(N/2)*(N-1) -> 0


< 정렬과 합병의 차이 >
정렬 : 정렬되지 않은 순서를 정렬하는것.
합병 : 정렬된 것이 2개 들어가는 것. 즉, 합병하려면 정렬되어 있어야 한다.

*Head Merge
[4,9,11,17]
[1,3,15,20]
-> 1번 index부터 각각 비교하면서 ++
[1,3,4,9,11,17,20] -> l2의 1번 선택 list2++, l2의 2번선택 l2++, l1의 1번선택 l1++, l1의 2번선택 l1++ .....


문서에서 사전의 탐색방법
Dictionary : {W_1, W_2, ... , W_m}
Document : {S_1, S_2, ... , S_n}

-> Document -> [가는|너는|....|형이] : Document의 단어들을 먼저 Sorting함 -> 그리고 Sorting후 각 단어별로 linkedList 형식으로 나온 index의 위치 저장. -> 다 끝난뒤에 document의 정렬 순서대로 탐색.
 


_________________________
[0528]

* MergeSort

- Worst : 
- Average :
- 


1) 추가메모리 : 세타(nc)
2) link -> 4 ->8 세타(n*l



* Heap 정렬(Sorting)
-> Priority Queue : Heap = complete Tree

		i -> 2i, 2i+1
			1
		2		3
	4	5		6	7
8


ex)

초기상태 : [8,2,14,10,4,6,9,21,30,1]


			8
		2		14
	10	4		6	9
21	30	1



Heap : 밑으로 내려가는건 정리가 되어 있는 것 (부분 소팅이 되어 있는것)
-> 집어넣으면서 자기 위치를 찾아가는 것.

			1
		2		6
	10	4		14	9
21	30	8




1. MeanHeap : min -> root
a) min 추출 : 세타(1)
b) adjust : 최대(log_2_N)




